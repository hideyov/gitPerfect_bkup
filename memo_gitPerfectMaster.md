# もう怖くないGit! チーム開発で必要なGitを完全マスター! 山浦講師

## Gitの設定

.gitconfig に登録したnameとemail

$ git config --global user.name [name]

git で使うエディターを登録 => $ git config --global core.editor "atom --wait"

設定の確認 => $ git config user.name, $ git config user.email

一度に確認したければ => $ git config --list

## Gitは差分でなく、スナップショットを保存している

branchを切る際やmergeする際に、スナップショットだと作業が早い。差分だと、いちいち計算しないといけない。

コミットが、直前のコミットを記録している。

## gitの作業の流れ

ワークツリーでファイルを変更

git add：コミットする変更を準備(記録したい変更分だけをstageに切り分けておく)

git commit：ステージに追加された変更を、スナップショットとしてリポジトリに記録

## コマンドの裏で何が起きているのか〜Gitのデータの持ち方（コミットまでの流れ）

### index.htmlをステージに追加する時、何が起こっているか。

index.html の圧縮ファイルAをリポジトリに保存。（実際は、ファイルの中身にヘッダを付け加えた文字列を、ハッシュ関数で暗号化した文字列がファイル名となる）

git add == ファイル名(index.html)と圧縮ファイルA（ファイルの中身）をmappingした情報をインデックスに保存。

git commit == インデックスのファイル構成を元に、ツリー1というファイルが作られる。次にコミット1というファイルを作る。

コミット1には、ツリー１（ファイル名）、作成者、日付、コミットメッセージが記録される。コミット1から、その時のファイル状態(snap shot)と、誰がいつ何のために変更したのかがわかる。

gitはステージに追加してコミットする際、圧縮ファイル、ツリー、コミットという3種類のファイルを作成してデータを保存している。

### 新しいファイル、css/home.cssを追加したら

git add == css/home.cssの圧縮ファイルBが作成される。インデックスにファイル構成を追記する。

git commit == ツリー2が作成され、インデックスに記載されているファイル構成が保存される。コミット2が作成され、ツリー2というツリー名が記録される。直前のコミット（コミット1）を、自分の親コミットとして記録する。（変更履歴を連鎖してたどれるように）

ステージに追加した時はインデックスという一つのファイルに上書きしておいて、コミット（きちんと記録）する時だけ、ツリーというファイルに保存する。

### ファイルを変更したら

index.htmlだけを変更すると、index.htmlを圧縮した圧縮ファイルCのみがつくられる（圧縮ファイルは、ファイルの中身が違う時だけつくられる）。

インデックスファイルの情報が、index.htmlの圧縮ファイルがAからCに書き換えられる。ここまでが　[$ git add]

ツリー3が作成され、コミット3のツリーはツリー3、親コミットはコミット2となる。[$ git commit]

### Gitのデータ構造のまとめ

リポジトリに「圧縮ファイル」「ツリー」「コミット」ファイルを作成することでデータを保存。ステージに追加する時に「圧縮ファイル」が、コミットする時に「ツリー」「コミット」ファイルが作られる。

コミットが、親コミットへの参照を持つことで、変更履歴をたどることができる。

Gitの本質は、データを圧縮して、スナップショットで保存していること。

## .gitの中身は？

$ ls .git =>  COMMIT_EDITMSG  HEAD  config  description  hooks  index  info  logs  objects  refs

objects：圧縮ファイルやツリーファイル、コミットファイルが保存される、リポジトリの本体

config：Gitの設定ファイル。

## GitHub上にすでにあるプロジェクトから始める

$ git clone <リポジトリ名> => リモートリポジトリのファイルがワークツリーにコピーされ、.gitリポジトリがコピーされる。

### 変更を記録する(commit)

~$ git commit ：Gitのテキストエディターが立ち上がって、メッセージ付きで保存

~$ git commit -m <メッセージ>：いちいち、エディターを立ち上げなくて済む

~$ git commit -v ：エディターが立ち上がり、ファイルの変更内容を確認することができる。

### コミットメッセージの正式な書き方

1行目＝変更内容の要約、2行目＝改行、3行目＝変更した理由（チーム内、オープンソースへのコミットには正式な記法で！）

### 現コミットやステージ追加の前に、どのファイルが変更されたか確認する！

git status => ワークツリーとステージ、ステージとリポジトリの間で変更されたファイルを表示している。

### 変更差分を確認する

$ git diff (<ファイル名>)：git add する前の変更分を確認（ワークツリート、ステージの変更差分）

$ git diff --staged：git add した後の変更分を確認（ステージとコミットの変更差分）

### 変更履歴の確認

$ git log --oneline ：1行で表示、 $ git log -p <ファイル名>：特定ファイルの変更分を表示、$ git log -n <コミット数>：表示するコミット数を指定
    
git log で表示されるハッシュ値は、コミットのIDのようなもの。

### ファイルの削除を記録する

コミットされた記録だけでなく、ワークツリーのファイルごと削除したい =>　$ git rm <ファイル名> / $ git rm -r <ディレクトリ名>

ワークツリーにファイルは残したいが、Gitの記録からだけファイルを削除したい =>　$ git rm --cached <ファイル名>

例えば、passWordの入ったファイルを間違ってGitにあげてしまったような時は、gir rm --cachedを使う。

### 元の状態に戻す

git rm で削除したファイルを元に戻すには $ git reset HEAD <ファイル名> に続いて、$ git checkout <ファイル名>

この2段構えでファイルが復活し、git status で見ても「変更点がなく」なる。コマンドの意味は、後で詳しく。

git rm --cached index.html を実行すると、ファイルは残っている。git status では、Changes to be commited（コミットすべき変更）として、index.html がdeletedされたこと、Untracked files（Gitで追跡していない、新規ファイル）としてindex.htmlがある、と表示される。

git rm --cached でGitの記録から削除したファイルも、 git reset HEAD index.html で元に戻せる。

### ファイルの移動を記録する

$ git mv <旧ファイル> <新ファイル> これは、下記の3連続コマンドと等価。

$ mv <旧ファイル> <新ファイル> => $ git rm <旧ファイル> => $ git add <新ファイル>

## GitHubにプッシュする

チームメンバーに自分の開発したコードを共有する時、GitHubにローカルの内容を保存したい時。

### リモートリポジトリ(GitHub)を新規追加

$ git remote add origin https://github.com/user/repo.git <-- originというショートカットでurlのリモートリポジトリを登録するよ

今後はoriginという名前で、GitHubリポジトリにアップしたり、取得できるようになる（いちいち、URLを入力せずにすむ）

'origin'はGitの慣用句みたいなもの。git cloneをしてきた時に、clone元のもともとのリモートリポジトリをgitではorigin というショートカットに割り当てている。そのため、メインのリモートリポジトリのことを通常、originと名付ける。

### リモートリポジトリ(GitHub)に送信

$ git push <リモート名> <ブランチ名> 具体的には $ git push origin master

$ git push -u origin master <-- 初回プッシュ時にオプション -u をつけると次回以降は [git push]だけでpushできる。
